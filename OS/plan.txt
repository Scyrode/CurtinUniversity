0 24 1
1 23 2
3 1 2
4 20 3
4 100 1

------ 0
| P1 |
------ 24
| P5 |
------ 124
| P3 |
------ 125
| P2 |
------ 148
| P4 |
------ 168

- Read file:
	- A process should be a struct that contains:
		- Arrival Time
		- Burst Time
		- Priority
		- Completed (bool) (?)
		- Turn Around Time (calculated once completed)
		- Waiting Time = Turn Around Time - Arrival Time (calculated once completed)
	- First, create a "ProcessExecuting" and initialise to the first line read.
	- For each process read:
		- Set the "currentTime" & Burst Time of processExecuting:
			- if ((Arrival time of new process - currentTime) > Burst time of processExecuting): 
				Burst Time of processExecuting = 0
				currentTime += Burst Time of processExecuting
			- else:
				Burst Time of processExecuting -= (Arrival time of newProcess - "currentTime")
				currentTime = Arrival time of new process
		- check if its priority is higher than the one executing, if so, make it the
			currently running process and put the process that was previously executing in the "readyQueue".
			If the read process has a lower priority than the one executing, simply add it to the "readyQueue".
	- Print to the command line when:
		- A process's burst time reaches 0 OR
		- When preemption happens (process executing is swapped out)
	- {ASSUMPTION}: The processes in the input file are sorted by their arrival time
	- Whenever a process's busrt time reaches 0, add it to the "completedProcesses" list (used at the end for
		calculating the average wait time and average turn around time)
	- Whenever a process is required from the ready "readyQueue" (which happens when a process's burst time
		reaches 0), the readyQueue must first be sorted by highest priority. If processes have the same
		priority, the process with the shorter burst time is placed first. This results in the process
		with the highest priority to be at the head of the "readyQueue". That process is now made the
		"ProcessExecuting" and it is removed from the "readyQueue".
	- Once there are no more lines to be read, execute all the process in the "readyQueue" (only sort once
		as no new process are added once the file has reached its end).
	- Once the "readyQueue" is empty and "processExecuting"'s burst time reached 0, calculate the average
		waiting time and average turn around time by looping through the "completedProcesses" list.